<!doctype html>
<html lang="en-ca">
<meta charset="utf-8">
<meta
	name="viewport"
	content="width=device-width, initial-scale=1.0">
<link
	rel="stylesheet"
	href="/contents/stylesheets/main.css">

<link
	rel="alternate"
	href="/contents/atom.xml"
	title=""
	type="application/atom+xml">
<title>
	 » Chee ♥️
</title>

<header class="header">
	<a class="header-link" href="/">
		chee
	</a>
	/
	<a class="header-link" href="/contents/">
		contents
	</a>
	
		/
		<a class="header-link active" href="/contents/typescript/">
			
		</a>
	
</header>

<main role="main" class="main">
	
		
		
<time
	class="post-time "
	datetime="2019-07-17T09:49:18.083Z">
	2019-07-17
	<small>10:49:18 a.m.</small>
</time>

	
	<h1>why i don't want to use typescript</h1>
<p>Imagine adding a compile step for no other reason than so you can have compile
failures. Compiling a massive application takes 0 time in JavaScript, we can
catch these problems in runtime (like Smalltalk).</p>
<p>Tests exist, and can make sure we visit every part of the code. Type checking
can only test that types are correct.</p>
<p>Types are not automatic tests, I still have to write an incomprehensible,
mathematically pornographical test in each function signature. It's not
automatic, I have to do it at every variable declaration.</p>
<p>Instead of a readable, semantic test with comments. Everything types can do, a
test can do.</p>
<p>Type checking can only test that types are correct.</p>
<p>Wrong types are so <b>very</b> rarely the problem when code is broken.</p>
<p>Tern can figure out that <code>undefined.undefined</code> is not a function. Flow also
infers types, until you export a function when it demands you declare
signatures. That is enough to notice when types are changing, or when you are
trying to access a property on something that might be undefined.</p>
<p>A test can describe how something works, why it works. In words and in
expression. Not something impenetrable. Like this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="highlight-line"><span class="token keyword">type</span> Chainable<span class="token operator">&lt;</span><span class="token constant">L</span> <span class="token keyword">extends</span> <span class="token class-name">LibTemplate</span><span class="token punctuation">,</span> <span class="token constant">V</span> <span class="token keyword">extends</span> <span class="token class-name">L</span><span class="token punctuation">[</span>keyof <span class="token constant">L</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'arg'</span> <span class="token operator">|</span> <span class="token string">'ret'</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">  value<span class="token punctuation">:</span> <span class="token constant">V</span></span><br><span class="highlight-line"><span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span></span><br><span class="highlight-line">    <span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">in</span> keyof <span class="token constant">L</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">:</span> Chainable<span class="token operator">&lt;</span><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">L</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'arg'</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> Chainable<span class="token operator">&lt;</span><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">L</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ret'</span><span class="token punctuation">]</span><span class="token operator">></span></span><br><span class="highlight-line"><span class="token punctuation">}</span></span></code></pre>
<p>That's from here: <a href="https://stackoverflow.com/questions/48586171/re-using-interfaces-for-dynamic-methods/48587544#48587544">a question my colleague asked about dynamically declaring
method types</a></p>
<p><b><b>Static types kill innovation.</b></b> Any time somebody asks on stackoverflow &quot;How
do i describe x library's api in typescript?&quot; and it takes a long time to find a
satisfying answer: there's a library that would have never existed without
dynamic types.</p>
<p>When they add something new to typescript so that you can use it with a library
that didn't used to work with typescript, there's a library that never would
have been written if we were using typescript.</p>

</main>
